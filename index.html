<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>张帅的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="张帅的个人博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="张帅的个人博客">
<meta property="og:locale">
<meta property="article:author" content="张帅">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="张帅的个人博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">张帅的个人博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-设计模式总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/12/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2023-12-15T16:00:00.000Z" itemprop="datePublished">2023-12-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/12/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/">设计模式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1：策略-模版-工厂"><a href="#1：策略-模版-工厂" class="headerlink" title="1：策略 + 模版 + 工厂"></a>1：策略 + 模版 + 工厂</h2><p>当我们有多个分支的时候，我们可以把这些分支作为一个个的策略，公共的东西放到模板中，多个策略交给工厂去管理；</p>
<p>具体的：</p>
<p>​	比如，有一个支付流程包括三个逻辑：</p>
<ul>
<li>支付前置处理</li>
<li>支付处理</li>
<li>支付后置处理</li>
</ul>
<p>其中，支付前置和后置都是公共的，可以把他们放在抽象类中，直接实现；</p>
<p>然后支付处理，根据不同的支付类型实现不同的实现类，作为策略；</p>
<p>策略交给工厂去管理，在工厂中创建一个 Map，所有策略注入进去，然后提供一个通过支付类型获取对应支付策略的get 方法；</p>
<h3 id="2：具体代码"><a href="#2：具体代码" class="headerlink" title="2：具体代码"></a>2：具体代码</h3><ul>
<li>模版：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractPayService</span> <span class="keyword">implements</span> <span class="title class_">PayService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(PayRequest payRequest)</span> &#123;</span><br><span class="line">      	<span class="comment">//前置检查</span></span><br><span class="line">        validateRequest(payRequest);</span><br><span class="line">      	<span class="comment">//支付核心逻辑</span></span><br><span class="line">        doPay(payRequest);</span><br><span class="line">      	<span class="comment">//后置处理</span></span><br><span class="line">        postPay(payRequest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doPay</span><span class="params">(PayRequest payRequest)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postPay</span><span class="params">(PayRequest payRequest)</span> &#123;</span><br><span class="line">        <span class="comment">//支付成功的后置处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validateRequest</span><span class="params">(PayRequest payRequest)</span> &#123;</span><br><span class="line">        <span class="comment">//参数检查</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>多个策略</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AlipayPayService</span> <span class="keyword">extends</span> <span class="title class_">AbstractPayService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPay</span><span class="params">(PayRequest payRequest)</span> &#123;</span><br><span class="line">        <span class="comment">//支付宝支付逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WechatPayService</span> <span class="keyword">extends</span> <span class="title class_">AbstractPayService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPay</span><span class="params">(PayRequest payRequest)</span> &#123;</span><br><span class="line">        <span class="comment">//微信支付逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>工厂</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayServiceFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, PayService&gt; payServiceMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PayService <span class="title function_">getPayService</span><span class="params">(String payChannel)</span> &#123;</span><br><span class="line">        <span class="comment">// alipay -&gt; alipayPayService</span></span><br><span class="line">        <span class="comment">// wechat -&gt; wechatPayService</span></span><br><span class="line">        <span class="keyword">return</span> payServiceMap.get(payChannel + <span class="string">&quot;PayService&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>使用的时候</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayDomainService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    PayServiceFactory payServiceFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(PayRequest payRequest)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">payChannel</span> <span class="operator">=</span> payRequest.getPayChannel();</span><br><span class="line">        payServiceFactory.getPayService(payChannel).pay(payRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2：享元模式-工厂模式"><a href="#2：享元模式-工厂模式" class="headerlink" title="2：享元模式 + 工厂模式"></a>2：享元模式 + 工厂模式</h2><p>当我们需要用不同的司机账户参数创建对象时，可以在工厂类中定义一个 Map 作为缓存。每次从 Map 中根据不同的参数获取对应的对象，如果对象不存在，就先创建这个对象并放入 Map 中，然后下次再遇到相同参数时，直接从 Map 中获取已创建的对象。</p>
<h3 id="2：具体代码-1"><a href="#2：具体代码-1" class="headerlink" title="2：具体代码"></a>2：具体代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体的汽车类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String color;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteCar</span><span class="params">(String brand, String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.brand = brand;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating a new &quot;</span> + color + <span class="string">&quot; &quot;</span> + brand + <span class="string">&quot; car.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 汽车工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarFactory</span> &#123;</span><br><span class="line">    <span class="comment">// 缓存汽车实例的 Map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Car&gt; carMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title function_">getCar</span><span class="params">(String brand, String color)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据品牌和颜色生成唯一的 key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> brand + <span class="string">&quot;-&quot;</span> + color;</span><br><span class="line">        <span class="comment">// 从缓存中获取汽车实例</span></span><br><span class="line">        <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> carMap.get(key);</span><br><span class="line">        <span class="comment">// 如果不存在，则创建新的汽车实例并放入缓存</span></span><br><span class="line">        <span class="keyword">if</span> (car == <span class="literal">null</span>) &#123;</span><br><span class="line">            car = <span class="keyword">new</span> <span class="title class_">ConcreteCar</span>(brand, color);</span><br><span class="line">            carMap.put(key, car);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlyweightPatternExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Car</span> <span class="variable">car1</span> <span class="operator">=</span> CarFactory.getCar(<span class="string">&quot;Toyota&quot;</span>, <span class="string">&quot;Red&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Car</span> <span class="variable">car2</span> <span class="operator">=</span> CarFactory.getCar(<span class="string">&quot;Toyota&quot;</span>, <span class="string">&quot;Red&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3：责任链模式"><a href="#3：责任链模式" class="headerlink" title="3：责任链模式"></a>3：责任链模式</h2><p>类似于审批流这样的场景中，每一步通过后才能流转到下一步；</p>
<p>那么，我们先定义一个 handler 接口，提供两个抽象方法：处理具体逻辑的方法、传递到下一个handler 的方法 setNextHandler 方法；</p>
<p>每一步都是一个handler 实现handler 接口，用的时候，定义好责任链顺序，通过不断的 setNext ，流转到下一个handler。如果检验不通过，流转终止。</p>
<p>在责任链模式下，要新增和删除一个分支流程也是很方便的。</p>
<h3 id="2：具体代码-2"><a href="#2：具体代码-2" class="headerlink" title="2：具体代码"></a>2：具体代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象处理器接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">OrderHandler</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">handleOrder</span><span class="params">(Order order)</span> <span class="keyword">throws</span> OrderProcessingException;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setNextHandler</span><span class="params">(OrderHandler nextHandler)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数校验处理器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ParameterValidationHandler</span> <span class="keyword">implements</span> <span class="title class_">OrderHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> OrderHandler nextHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleOrder</span><span class="params">(Order order)</span> <span class="keyword">throws</span> OrderProcessingException &#123;</span><br><span class="line">        <span class="comment">// 假设检查订单参数是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (order == <span class="literal">null</span> || order.getParameter() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OrderProcessingException</span>(<span class="string">&quot;参数校验失败: 订单参数不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;参数校验通过&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nextHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">            nextHandler.handleOrder(order);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNextHandler</span><span class="params">(OrderHandler nextHandler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nextHandler = nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 库存校验处理器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StockValidationHandler</span> <span class="keyword">implements</span> <span class="title class_">OrderHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> OrderHandler nextHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleOrder</span><span class="params">(Order order)</span> <span class="keyword">throws</span> OrderProcessingException &#123;</span><br><span class="line">        <span class="comment">// 假设检查库存是否充足</span></span><br><span class="line">        <span class="keyword">if</span> (!order.isStockAvailable()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OrderProcessingException</span>(<span class="string">&quot;库存校验失败: 库存不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;库存校验通过&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nextHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">            nextHandler.handleOrder(order);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNextHandler</span><span class="params">(OrderHandler nextHandler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nextHandler = nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义头节点</span></span><br><span class="line"><span class="type">OrderHandler</span> <span class="variable">parameterValidationHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParameterValidationHandler</span>();</span><br><span class="line">      <span class="type">OrderHandler</span> <span class="variable">stockValidationHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StockValidationHandler</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置责任链顺序</span></span><br><span class="line">      parameterValidationHandler.setNextHandler(stockValidationHandler);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建订单</span></span><br><span class="line">      <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>(<span class="string">&quot;Product123&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          parameterValidationHandler.handleOrder(order);</span><br><span class="line">          System.out.println(<span class="string">&quot;订单处理成功&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (OrderProcessingException e) &#123;</span><br><span class="line">          System.err.println(e.getMessage());</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>



<h2 id="4：代理模式"><a href="#4：代理模式" class="headerlink" title="4：代理模式"></a>4：代理模式</h2><p>一般用到静态代理和 JDK 的动态代理；</p>
<ul>
<li><p>静态代理是定义一个代理类，实现接口，然后在里面注入目标实现类，这样在重写的方法可以增强；</p>
</li>
<li><p>JDK 动态代理是使用反射。定义一个 handler 实现 InvocationHandler 接口，重写 invoke 方法，然后使用 Proxy.newProxyInstance 创建代理，然后在执行方法的时候，会走到代理类的 invoke 方法。</p>
</li>
</ul>
<h1 id="1：设计模式-7-大原则"><a href="#1：设计模式-7-大原则" class="headerlink" title="1：设计模式 7 大原则"></a>1：设计模式 7 大原则</h1><ul>
<li>单一职责</li>
</ul>
<p>​	一个类只做一件事</p>
<ul>
<li><p>接口隔离原则</p>
<p>强调的是应该使用多个小的接口，而不是一个大的接口啥都包含</p>
</li>
<li><p>开放闭合原则</p>
<p>开放性的对外扩展，而不是通过修改代码来实现</p>
</li>
<li><p>里氏替换原则</p>
<p>强调的是继承关系的正确性</p>
</li>
<li><p>依赖倒置原则</p>
<p>高层模块和底层模块的解耦，应该是通过抽象接口或者抽象类</p>
</li>
<li><p>迪米特法则</p>
<p>强调的是将负责的模块，拆分成小的模块，模块之间通过最少的接口交互</p>
</li>
<li><p>聚合和复用原则</p>
<p>构建对象的时候，应该用复用和聚合，而不是继承关系。</p>
</li>
</ul>
<h1 id="2：工厂模式"><a href="#2：工厂模式" class="headerlink" title="2：工厂模式"></a>2：工厂模式</h1><p>它是将对象的创建和使用分离开；</p>
<p>通过工厂创建对象代替 new ；避免重复写创建对象的代码；</p>
<p>工厂模式分为：</p>
<ul>
<li><p>简单工厂</p>
<p>它也叫静态工厂；</p>
</li>
<li><p>工厂方法</p>
</li>
<li><p>抽象工厂</p>
</li>
</ul>
<h1 id="3：观察者模式"><a href="#3：观察者模式" class="headerlink" title="3：观察者模式"></a>3：观察者模式</h1><p>就是一个对象发生改变的时候，跟他相关的对象都能感知，并自动更新。</p>
<p>这种模式减少对象之间的耦合度；</p>
<ul>
<li>举例子</li>
</ul>
<h1 id="4：装饰器模式"><a href="#4：装饰器模式" class="headerlink" title="4：装饰器模式"></a>4：装饰器模式</h1><p>给一个对象增加更多的功能的时候，不是直接在这个对象上修改代码，而是动态的去增加；</p>
<p>这种可以使对象的功能扩张更加可控和灵活；</p>
<h1 id="5：单例模式"><a href="#5：单例模式" class="headerlink" title="5：单例模式"></a>5：单例模式</h1><p>就是提供全局的唯一的访问点，不管多少次，访问的都是同一个实例；</p>
<h1 id="6：模板方法模式"><a href="#6：模板方法模式" class="headerlink" title="6：模板方法模式"></a>6：模板方法模式</h1><p>它的主要作用就是复用代码；</p>
<p>我们把公共的业务逻辑定义在父类中，然后在子类中定制化自己的业务逻辑；</p>
<p>我们通常会把策略模式、工厂模式和模版方法模式结合使用；</p>
<h1 id="7：享元模式"><a href="#7：享元模式" class="headerlink" title="7：享元模式"></a>7：享元模式</h1><p>享元模式是对一些共享对象的复用思想；这样做的好处是：减少了创建重复对象的开销，节省系统资源和内存；</p>
<p>很多地方都使用到了享元模式的思想：池化技术、包装类的缓存、字符串常量池；</p>
<p>它一般和工厂模式结合使用。工厂模式负责管理创建出来的对象，获取它的一个享元抽象或者实现类，从而实现复用思想。</p>
<h2 id="1：哪些地方使用了享元模式"><a href="#1：哪些地方使用了享元模式" class="headerlink" title="1：哪些地方使用了享元模式"></a>1：哪些地方使用了享元模式</h2><ul>
<li><p>包装类中的缓存</p>
</li>
<li><p>string 的字符串常量池</p>
</li>
</ul>
<h1 id="8：责任链模式"><a href="#8：责任链模式" class="headerlink" title="8：责任链模式"></a>8：责任链模式</h1><p>就是将请求发送者和多个接收者组成一条链，沿着这条链传递请求，直到有一个处理者处理它为止。</p>
<ul>
<li><p>例子：</p>
<p>过滤器链；</p>
<p>异常处理链</p>
<p>认证授权</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/12/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/" data-id="clxs9nvuj0026ikuwf3g1fd61" data-title="设计模式" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-微服务相关" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/11/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9B%B8%E5%85%B3/" class="article-date">
  <time class="dt-published" datetime="2023-11-15T16:00:00.000Z" itemprop="datePublished">2023-11-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/11/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9B%B8%E5%85%B3/">微服务</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1：啥是微服务"><a href="#1：啥是微服务" class="headerlink" title="1：啥是微服务"></a>1：啥是微服务</h1><p>微服务是分布式系统中的其中一种架构，分布式架构包括：</p>
<ul>
<li>BS 架构</li>
<li>CS 架构</li>
<li>微服务架构</li>
<li>SOA 架构</li>
<li>P2P 架构</li>
</ul>
<p>微服务关注的是业务层面的拆分、分布式架构关注的是系统级别的拆分；</p>
<h1 id="2：如果做微服务拆分"><a href="#2：如果做微服务拆分" class="headerlink" title="2：如果做微服务拆分"></a>2：如果做微服务拆分</h1><p>要做好微服务拆分，需要考虑的方面很多；</p>
<p>但是一般按照业务拆分成不同的业务模块，模块单独部署；</p>
<p>但是微服务拆分还要考虑服务治理问题；</p>
<h1 id="3：啥是-DevOps"><a href="#3：啥是-DevOps" class="headerlink" title="3：啥是 DevOps"></a>3：啥是 DevOps</h1><p>DevOps 是一种开发流程，或者说是一种开发文化；</p>
<p>它是通过软件开发与运维结合，保证软件能够安全、快速的交付；</p>
<p>能做到这一点是因为有，自动化的持续集成持续部署的软件出现。</p>
<h1 id="4：微服务中的-CI、CD-是啥"><a href="#4：微服务中的-CI、CD-是啥" class="headerlink" title="4：微服务中的 CI、CD 是啥"></a>4：微服务中的 CI、CD 是啥</h1><p>CI ：是持续继承</p>
<p>CD：持续部署</p>
<p>他们都是 DecOps 中的自动化流程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/11/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9B%B8%E5%85%B3/" data-id="clxs9nvu8001pikuw11y80m6e" data-title="微服务" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag">微服务</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-分布式理论" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/10/16/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/" class="article-date">
  <time class="dt-published" datetime="2023-10-15T16:00:00.000Z" itemprop="datePublished">2023-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/10/16/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/">分布式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1：分布式、集群"><a href="#1：分布式、集群" class="headerlink" title="1：分布式、集群"></a>1：分布式、集群</h1><h2 id="1：啥是集中式"><a href="#1：啥是集中式" class="headerlink" title="1：啥是集中式"></a>1：啥是集中式</h2><p>最早的集中式是把数据库、系统服务放在一起，集中对外提供一个访问入口，这种容易出现单点故障、可扩展性差；</p>
<p>这种单点故障问题在分布式中可以解决。</p>
<h2 id="2：啥是分布式"><a href="#2：啥是分布式" class="headerlink" title="2：啥是分布式"></a>2：啥是分布式</h2><p>分布式就是把一个单体应用按照业务功能垂直拆分，成不同的子模块系统</p>
<p>，分别部署在不同机器上防止单点故障，各个服务之间远程调用，对外也只是提供唯一的访问入口。比如：用户服务，订单服务。</p>
<p>原来在一块，现在各自成为一个服务。</p>
<h3 id="1：分布式系统要解决啥问题"><a href="#1：分布式系统要解决啥问题" class="headerlink" title="1：分布式系统要解决啥问题"></a>1：分布式系统要解决啥问题</h3><p>分布式系统存在通信延迟，一致性问题。</p>
<h4 id="1：一致性问题都有啥"><a href="#1：一致性问题都有啥" class="headerlink" title="1：一致性问题都有啥"></a>1：一致性问题都有啥</h4><pre><code> 按照分类：
</code></pre>
<ul>
<li><p>强一致性</p>
<p>就是任意时间点每个读操作，都是最近写操作的结果；</p>
<p>强一致性通常式牺牲可用性来保证。</p>
<p>强一致性又分为顺序一致性和线性一致性；</p>
</li>
<li><p>弱一致性</p>
<p>弱一致性放宽了一致性的严格条件；</p>
<p>它为了高可用性，牺牲了访问某些节点时候，读到的数据可以不是最新的。</p>
</li>
<li><p>最终一致性</p>
<p>它允许系统故障网络延迟之后一段时间，各个节点之间的数据最终都是相同的，保证的式一段时间内的一致性。</p>
</li>
</ul>
<h2 id="3：集群"><a href="#3：集群" class="headerlink" title="3：集群"></a>3：集群</h2><p>把分布式系统，在不同的机器上复制多份。通过负载均衡对外提供服务。</p>
<h1 id="2：分布式系统的第一步"><a href="#2：分布式系统的第一步" class="headerlink" title="2：分布式系统的第一步"></a>2：分布式系统的第一步</h1><p>CAP 原则，是分布式系统需要考虑的因素。</p>
<h2 id="1：CAP-原则"><a href="#1：CAP-原则" class="headerlink" title="1：CAP 原则"></a>1：CAP 原则</h2><ul>
<li><p>C 强一致性</p>
<p>每次的读操作，都会收到最近写操作的结果；</p>
</li>
<li><p>A 可用性</p>
<p>每个请求都能有所响应。</p>
</li>
<li><p>P 分区容错性</p>
<p>某些节点挂了，但是系统整体还是能提供对外服务。</p>
</li>
</ul>
<h2 id="2：BASE-理论-软状态"><a href="#2：BASE-理论-软状态" class="headerlink" title="2：BASE 理论 - 软状态"></a>2：BASE 理论 - 软状态</h2><p>BASE 理论是对 CAP 理论的一个补充。是说，如果达不到强一致性，使用中间状态软状态 + 降级，达到最终一致性也行，保证系统的核心功能和高可用。</p>
<p>BASE 理论和 ACID 不一样， ACID 是数据库层面的，它是一种强一致性的模型，BASE 是分布式系统中的，它是一种最终一致性的模型。</p>
<h1 id="4：分布式一致性问题"><a href="#4：分布式一致性问题" class="headerlink" title="4：分布式一致性问题"></a>4：分布式一致性问题</h1><h2 id="1：分布式一致性问题是啥"><a href="#1：分布式一致性问题是啥" class="headerlink" title="1：分布式一致性问题是啥"></a>1：分布式一致性问题是啥</h2><p>引出了拜占庭将军问题。</p>
<p>就是为了阐述分布式系统中相互独立的节点如何达成共识。</p>
<p>拜占庭将军问题就是分布式系统中的研究的一个重要问题。</p>
<h2 id="2：咋解决一致性问题"><a href="#2：咋解决一致性问题" class="headerlink" title="2：咋解决一致性问题"></a>2：咋解决一致性问题</h2><p>解决拜占庭将军问题的方法有很多：投票算法、共识性算法。</p>
<p>投票机制的背后原理是半数机制。</p>
<p>引入一致性算法；</p>
<h2 id="3：一致性算法有哪些"><a href="#3：一致性算法有哪些" class="headerlink" title="3：一致性算法有哪些"></a>3：一致性算法有哪些</h2><h3 id="1：Paxos-算法"><a href="#1：Paxos-算法" class="headerlink" title="1：Paxos 算法"></a>1：Paxos 算法</h3><p>它是最早提出来的解决分布式一致性问题的一种算法</p>
<h3 id="2：Raft-算法"><a href="#2：Raft-算法" class="headerlink" title="2：Raft 算法"></a>2：Raft 算法</h3><p>Raft 算法是为了替代难以理解的Paxos 算法；</p>
<p>Nacos 是 Raft 协议选举</p>
<h3 id="3：ZAB-协议"><a href="#3：ZAB-协议" class="headerlink" title="3：ZAB 协议"></a>3：ZAB 协议</h3><p>是 ZK 中的，专门为了解决 ZK 中节点同步的一致性算法。</p>
<p>ZAB 协议借鉴了 Paxos 算法；</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/10/16/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/" data-id="clxs9nvtv000zikuw94oaeg5c" data-title="分布式" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">分布式</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Nacos" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/16/Nacos/" class="article-date">
  <time class="dt-published" datetime="2023-09-15T16:00:00.000Z" itemprop="datePublished">2023-09-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/09/16/Nacos/">nacos</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1：nacos-配置中心变化，项目如何感知"><a href="#1：nacos-配置中心变化，项目如何感知" class="headerlink" title="1：nacos 配置中心变化，项目如何感知"></a>1：nacos 配置中心变化，项目如何感知</h1><p>客户端感知配置中心的变化，一般就两种模式：那么推，要么拉；</p>
<p>拉的模式：</p>
<p>​	客户端不断轮询服务端，有变化就把数据拉取回来。缺点是：无法实时性，轮询还会对服务端造成压力。</p>
<p>推的模式：</p>
<p>​	客户端跟服务端建立 TCP 连接，当服务端有变化时，通过这个连接，把数据推送给客户端；</p>
<p>​	优点是：实时性比较高，缺点是服务端要维护大量的 TCP，占用大量的 CPU 和内存。</p>
<p>nacos 中的做法是：</p>
<p>​	nacos 1 中使用长轮询，Long Polling;</p>
<p>​		过程是这样的：客户端向服务端发起长轮询请求，这是一个 Http 请求；nacos 不会立即返回结果，而是将这个请求挂起默认30s，当有变化时候，才响应客户端, 配置中心会为每个配置文件生成 MD5，比较的是 MD5 值有没有变化。这种方式是客户端需要不断的发起 HTTP 请求，实时性不是很高。这种是拉的模式。</p>
<p>​	nacos 2 采用 gRpc, 长连接；</p>
<p>​		过程是这样的：服务端主动发起，跟客户端建立 TCP 长连接；它们会保持心跳机制。客户端被动接受服务端变化的数据。这种的实时性更高。这种是推的模式。</p>
<h1 id="2：Nacos-能同时满足-AP-和-CP-的原因是啥"><a href="#2：Nacos-能同时满足-AP-和-CP-的原因是啥" class="headerlink" title="2：Nacos 能同时满足 AP 和 CP 的原因是啥"></a>2：Nacos 能同时满足 AP 和 CP 的原因是啥</h1><p>默认 AP 协议采用 raft 协议；</p>
<p>CP 协议采用 Disto 协议；</p>
<p>在这两种协议间切换。</p>
<h1 id="3：Nacos-相关"><a href="#3：Nacos-相关" class="headerlink" title="3：Nacos 相关"></a>3：Nacos 相关</h1><h2 id="1：两个模块"><a href="#1：两个模块" class="headerlink" title="1：两个模块"></a>1：两个模块</h2><p>nacos 有两个核心的模块，naming server 提供注册功能，config server 提供配置功能；</p>
<p>它还继承普罗米修斯来提供监控功能，granfna 提供面板可视化。</p>
<h2 id="2：配置文件优先级"><a href="#2：配置文件优先级" class="headerlink" title="2：配置文件优先级"></a>2：配置文件优先级</h2><ul>
<li>backend.yml</li>
<li>beckend-dev.yml</li>
<li>扩展文件</li>
<li>共享文件</li>
</ul>
<h1 id="4：注册中心流程"><a href="#4：注册中心流程" class="headerlink" title="4：注册中心流程"></a>4：注册中心流程</h1><ul>
<li><p>注册中心</p>
<p>NameService</p>
</li>
</ul>
<p>提供者将自己的实例注册到注册中心，之后，注册中心封装成一个 ConcurrentHashMap，缓存到内存；</p>
<p>消费者启动后：</p>
<p>​	会从注册中心读取需要的提供者的信息，缓存到本地；并开启一个定时任务线程池每隔 10 s 轮询从注册中心获取服务最新列表, 调用的是 NameService 的 getInstance 方法。会有 10s 的延迟。</p>
<p>注册中心会建立一个跟提供者的心跳机制，监控提供者的情况，当发现提供者有连接超时，就把消息推送给消费者更新本地缓存。</p>
<p>心跳机制是一个 UDP 协议的连接，是一个不可靠的传输，但是它无序保证消息变更的实时性，因为还有消费者的 pull 消息。</p>
<h2 id="1：提供者咋注册"><a href="#1：提供者咋注册" class="headerlink" title="1：提供者咋注册"></a>1：提供者咋注册</h2><p>其实就是发起一个 HTTP 请求到注册中心，注册中心是 nameService 这个接口，调用它的 registerInstance（instance） 。</p>
<p>临时实例：封装好信息去注册，同时发送 http 心跳，每隔 5 s 心跳一次。</p>
<p> 永久实例不心跳。</p>
<h3 id="1：namingservice-咋处理心跳机制"><a href="#1：namingservice-咋处理心跳机制" class="headerlink" title="1：namingservice 咋处理心跳机制"></a>1：namingservice 咋处理心跳机制</h3><p>得到心跳数据之后，更新实例的心跳时间。</p>
<p>如果一个服务在 3 个心跳周期内，还没发送心跳，那么就标记为不健康；</p>
<p>如果在 6 个心跳周期内，还没发送心跳，那么就下线它</p>
<p>永久实例的心跳是主动检测模式。</p>
<h2 id="2：注册中心拿到请求之后呢"><a href="#2：注册中心拿到请求之后呢" class="headerlink" title="2：注册中心拿到请求之后呢"></a>2：注册中心拿到请求之后呢</h2><p>会封装到一个 ConcurerentHashMap 中：</p>
<h3 id="1-：Nacos-的分级存储模型"><a href="#1-：Nacos-的分级存储模型" class="headerlink" title="1 ：Nacos 的分级存储模型"></a>1 ：Nacos 的分级存储模型</h3><p><img src="C:\Users\Administrator\Nutstore\1\我的坚果云\笔记\面试准备\SpringCloud\image-20240602173327956.png" alt="image-20240602173327956"></p>
<h3 id="2：NamingService-在存储这个结构的时候，是如何抗住10W并发"><a href="#2：NamingService-在存储这个结构的时候，是如何抗住10W并发" class="headerlink" title="2：NamingService 在存储这个结构的时候，是如何抗住10W并发"></a>2：NamingService 在存储这个结构的时候，是如何抗住10W并发</h3><p>也就是注册时候，服务端保存注册数据的流程；</p>
<p>一方面它会做集群、负载均衡，另一方面它会在代码层面做了优化；</p>
<p>代码上咋做优化的呢：</p>
<ul>
<li><p>先注册保存到 Map</p>
<p>它在保存的时候，不着急保存，而是把这些要保存的数据放到阻塞队列中走异步保存；它在namingService 启动的时候，就已经启动了一个线程一个死循环，从阻塞队列中拿数据做处理。这个死循环不会对性能造成影响，因为没数据时，它会释放CPU。</p>
</li>
<li><p>做数据同步到 Follower 节点</p>
<p>临时实例用的是：Distor 协议</p>
<p>永久实例用的是：Raft 协议</p>
<p>默认是临时实例。</p>
<p>这一步是比较耗时的，里边也是采用阻塞队列异步执行。</p>
</li>
</ul>
<h3 id="3：要是在保存到-map-过程中有并发读写问题，咋处理"><a href="#3：要是在保存到-map-过程中有并发读写问题，咋处理" class="headerlink" title="3：要是在保存到 map 过程中有并发读写问题，咋处理"></a>3：要是在保存到 map 过程中有并发读写问题，咋处理</h3><p>它利用 CopyOnwrite 思想，同时加了 sync 锁，锁的对象是实例，单个实例之间串行执行，多个实例之间互不影响。</p>
<h1 id="5：Nacos-节点之间通信的变化"><a href="#5：Nacos-节点之间通信的变化" class="headerlink" title="5：Nacos 节点之间通信的变化"></a>5：Nacos 节点之间通信的变化</h1><p>1.0 中节点之间是 Http 协议。</p>
<p>2.0 中是 grpc 协议。</p>
<p>grpc 协议是基于 Http 2.0 。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/16/Nacos/" data-id="clxs9nvtd0008ikuw4y5pd4w7" data-title="nacos" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nacos/" rel="tag">nacos</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Springcloud" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/16/Springcloud/" class="article-date">
  <time class="dt-published" datetime="2023-08-15T16:00:00.000Z" itemprop="datePublished">2023-08-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/16/Springcloud/">服务治理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1：服务治理"><a href="#1：服务治理" class="headerlink" title="1：服务治理"></a>1：服务治理</h1><h2 id="1：网关-GateWay"><a href="#1：网关-GateWay" class="headerlink" title="1：网关 GateWay"></a>1：网关 GateWay</h2><h3 id="1：GateWay-总结"><a href="#1：GateWay-总结" class="headerlink" title="1：GateWay 总结"></a>1：GateWay 总结</h3><p>gateway 路由转发，全局过滤器；</p>
<p>作为项目网关；统一的入口；</p>
<p>每个路由都有自己的过滤器，还可以设置一个全局的过滤器；</p>
<p>我们这个 gateway 主要是做一个 JWT 的一个认证，用户登录后会生成一个 JWT 的 token，然后前端请求在 header 中携带这个 token,</p>
<p>gateway 做拦截，之后解析，并做一个续期放到 redis 中，超时redis 会删除它。gateway 主要做一个 JWT 的一个 filter, 一个 golbalFilter 拦截，然后转发给对应的服务。</p>
<h3 id="2：这样写"><a href="#2：这样写" class="headerlink" title="2：这样写"></a>2：这样写</h3><p>这样配置 </p>
<p>​	routes</p>
<p>​		id: 服务名字</p>
<p>​		uri:</p>
<p>​		lb 动态路由从注册中心获取的服务名一样</p>
<p>​		 predicate：断言</p>
<p>​			path:</p>
<h3 id="3：gateway-三大核心"><a href="#3：gateway-三大核心" class="headerlink" title="3：gateway 三大核心"></a>3：gateway 三大核心</h3><ul>
<li><p>路由</p>
<p>它是由 id 一般就是服务名唯一，URI 组成</p>
</li>
<li><p>断言</p>
<p>就是一个boolean 值</p>
</li>
<li><p>过滤器</p>
<p>是对路由的增强，在路由前后做一些事</p>
<p>它是根据断言是否匹配，来路由到具体的服务。</p>
</li>
</ul>
<h3 id="4：gateway-的工作流程是啥"><a href="#4：gateway-的工作流程是啥" class="headerlink" title="4：gateway 的工作流程是啥"></a>4：gateway 的工作流程是啥</h3><p>它大致分为几个步骤：</p>
<ul>
<li><p>路由转发</p>
</li>
<li><p>断言判断</p>
<ul>
<li><p>内置断言</p>
<p>请求头上加上 cookie、特定参数、指定时间起作用等</p>
</li>
<li><p>自定义断言</p>
</li>
</ul>
</li>
<li><p>执行过滤器链</p>
<ul>
<li><p>内置过滤器</p>
<p>请求头上加上一些东西</p>
</li>
<li><p>自定义过滤器</p>
<p>定义一个过滤器实现 GolabFiler</p>
</li>
</ul>
</li>
</ul>
<p>具体是：当一个请求首先得达到 gateway，先经过 gateway handlerMapping 处理，根据断言它符合哪个路由规则，然后在发送到 Web Handler ，Handler 再根据具体的过滤器链转发到具体的服务。</p>
<h3 id="5：gateway-如何实现动态路由"><a href="#5：gateway-如何实现动态路由" class="headerlink" title="5：gateway 如何实现动态路由"></a>5：gateway 如何实现动态路由</h3><p>默认情况下，gateway 会从注册中心拉取服务列表，用服务名作为动态路由进行转发，从而实现动态路由功能。</p>
<p><img src="C:\Users\Administrator\Nutstore\1\我的坚果云\笔记\面试准备\SpringCloud\image-20240603092715944.png" alt="image-20240603092715944"></p>
<h2 id="2：服务间通信"><a href="#2：服务间通信" class="headerlink" title="2：服务间通信"></a>2：服务间通信</h2><ul>
<li><p>同步</p>
<p>http</p>
</li>
<li><p>异步</p>
<p>MQ</p>
</li>
</ul>
<h2 id="3：注册中心"><a href="#3：注册中心" class="headerlink" title="3：注册中心"></a>3：注册中心</h2><p>zk</p>
<p>eureka</p>
<h2 id="4：配置中心-nacos"><a href="#4：配置中心-nacos" class="headerlink" title="4：配置中心 nacos"></a>4：配置中心 nacos</h2><h2 id="5：负载均衡-容错机制"><a href="#5：负载均衡-容错机制" class="headerlink" title="5：负载均衡 + 容错机制"></a>5：负载均衡 + 容错机制</h2><h3 id="1：负载均衡包括："><a href="#1：负载均衡包括：" class="headerlink" title="1：负载均衡包括："></a>1：负载均衡包括：</h3><ul>
<li><p>服务端负载均衡</p>
<p>nginx</p>
</li>
<li><p>客户端负载均衡</p>
<p>比如：dubbo、ribbon、springcloud loadblance，他们三个的原理一样</p>
</li>
</ul>
<h3 id="2：客户端负载均衡原理"><a href="#2：客户端负载均衡原理" class="headerlink" title="2：客户端负载均衡原理"></a>2：客户端负载均衡原理</h3><ul>
<li>从注册中心拉取服务配置列表，缓存到本地；</li>
<li>然后通过负载均衡算法，选择服务实例</li>
<li>之后，如果失败，走容错机制</li>
</ul>
<h3 id="3：负载均衡算法"><a href="#3：负载均衡算法" class="headerlink" title="3：负载均衡算法"></a>3：负载均衡算法</h3><ul>
<li>加权随机</li>
<li>加权轮询</li>
<li>一致性哈希</li>
<li>最小连接数</li>
<li>最短响应时间</li>
</ul>
<h3 id="4：容错机制"><a href="#4：容错机制" class="headerlink" title="4：容错机制"></a>4：容错机制</h3><ul>
<li>重试2次 + 切换到其他机器</li>
<li>忽略异常</li>
<li>并行访问，只要有一个成功就返回</li>
</ul>
<h2 id="6：熔断、限流、降级"><a href="#6：熔断、限流、降级" class="headerlink" title="6：熔断、限流、降级"></a>6：熔断、限流、降级</h2><h3 id="1：名词解释"><a href="#1：名词解释" class="headerlink" title="1：名词解释"></a>1：名词解释</h3><ul>
<li><p>熔断</p>
<p>当服务不可用时候，断开服务，防止重试导致服务雪崩；</p>
<p>一般配置慢调用比例 RT、熔断时间</p>
</li>
<li><p>限流</p>
<p>限制调用方的访问量;</p>
<p>限流算法：固定时间窗口、滑动时间窗口、漏桶算法、令牌桶</p>
<p>一般配置 QPS </p>
</li>
<li><p>降级</p>
<p>关闭非核心功能，优先保证核心功能正常</p>
</li>
</ul>
<h3 id="2：限流算法"><a href="#2：限流算法" class="headerlink" title="2：限流算法"></a>2：限流算法</h3><h4 id="1：固定时间窗口算法"><a href="#1：固定时间窗口算法" class="headerlink" title="1：固定时间窗口算法"></a>1：固定时间窗口算法</h4><p>这是最简单的一种方式；</p>
<p>比如：它有一个全局的计数器，定义在 1 s 内请求次数不能超过 100次；在这 1s 内，每请求一次，次数都会加1；</p>
<p>但是这种方式存在问题：可能会出现在前面都没有请求，在最后 1毫秒出现 100次请求。</p>
<h4 id="2：滑动时间窗口算法-sentinel-限流就是利用这个"><a href="#2：滑动时间窗口算法-sentinel-限流就是利用这个" class="headerlink" title="2：滑动时间窗口算法 - sentinel 限流就是利用这个"></a>2：滑动时间窗口算法 - sentinel 限流就是利用这个</h4><p>为了解决固定时间窗口算法的临界值缺陷；</p>
<ul>
<li>将大时间窗口分为多个小时间窗口</li>
<li>每一个小的时间窗口都有一个计数器</li>
<li>请求过来时候，计算落在哪个窗口，更新计数器</li>
<li>总的请求数 &#x3D; 所有时间窗口的计数器之和</li>
</ul>
<p>ZSET 实现</p>
<h4 id="3：漏桶算法"><a href="#3：漏桶算法" class="headerlink" title="3：漏桶算法"></a>3：漏桶算法</h4><p>所有请求都进入一个漏桶，处理线程每次从桶中处理相同数量的请求；</p>
<h4 id="4：令牌桶算法"><a href="#4：令牌桶算法" class="headerlink" title="4：令牌桶算法"></a>4：令牌桶算法</h4><p>由于漏桶只能匀速处理，于是推出令牌桶；</p>
<p>令牌桶是往桶里放入一定数量的令牌，请求过来的时候，先从桶中拿令牌，能拿到就执行，拿不到就放弃请求。</p>
<p>guave 实现</p>
<h3 id="3：Sentinel-落地经验"><a href="#3：Sentinel-落地经验" class="headerlink" title="3：Sentinel 落地经验"></a>3：Sentinel 落地经验</h3><h4 id="1：使用"><a href="#1：使用" class="headerlink" title="1：使用"></a>1：使用</h4><p>sentinel 有两个重要的概念：</p>
<ul>
<li><p>资源</p>
<p>要熔断的接口、方法、甚至还有代码</p>
</li>
<li><p>规则</p>
<p>如何保护资源：是限流还是降级</p>
</li>
</ul>
<h4 id="2：代码中"><a href="#2：代码中" class="headerlink" title="2：代码中"></a>2：代码中</h4><h5 id="1：在-controller上写"><a href="#1：在-controller上写" class="headerlink" title="1：在 controller上写"></a>1：在 controller上写</h5><p><img src="C:\Users\Administrator\Nutstore\1\我的坚果云\笔记\面试准备\SpringCloud\image-20240618152436103.png" alt="image-20240618152436103"></p>
<h5 id="2：注册到了-sentinel-中"><a href="#2：注册到了-sentinel-中" class="headerlink" title="2：注册到了 sentinel 中"></a>2：注册到了 sentinel 中</h5><p>代码中加过之后，表示资源就被注册到 sentinel 上了</p>
<p><img src="C:\Users\Administrator\Nutstore\1\我的坚果云\笔记\面试准备\SpringCloud\image-20240618152725269.png" alt="image-20240618152725269"></p>
<h5 id="3：配置限流"><a href="#3：配置限流" class="headerlink" title="3：配置限流"></a>3：配置限流</h5><p><img src="C:\Users\Administrator\Nutstore\1\我的坚果云\笔记\面试准备\SpringCloud\image-20240618153038945.png" alt="image-20240618153038945"></p>
<h5 id="4：配置降级"><a href="#4：配置降级" class="headerlink" title="4：配置降级"></a>4：配置降级</h5><p><img src="C:\Users\Administrator\Nutstore\1\我的坚果云\笔记\面试准备\SpringCloud\image-20240618152751674.png" alt="image-20240618152751674"></p>
<h5 id="5：触发之后的异常应该怎么处理的策略"><a href="#5：触发之后的异常应该怎么处理的策略" class="headerlink" title="5：触发之后的异常应该怎么处理的策略"></a>5：触发之后的异常应该怎么处理的策略</h5><ul>
<li><p>读降级</p>
<ul>
<li><p>正常走数据库；</p>
<p>降级之后走 redis </p>
</li>
<li><p>非关键性的读操作，返回默认值或者给出提示。</p>
</li>
</ul>
</li>
<li><p>写降级（要考虑数据一致性）</p>
<ul>
<li><p>异步 MQ</p>
</li>
<li><p>本地日志</p>
</li>
<li><p>状态标记之后重试</p>
<p>这种的有风险，因为本来就是熔断了的。</p>
</li>
</ul>
</li>
</ul>
<h5 id="6：降级之后恢复的策略"><a href="#6：降级之后恢复的策略" class="headerlink" title="6：降级之后恢复的策略"></a>6：降级之后恢复的策略</h5><ul>
<li><p>当发生降级时候，与注册中心通信，调整当前服务实例的负载均衡权重；</p>
</li>
<li><p>当降级恢复之后，恢复负载均衡权重；</p>
</li>
</ul>
<p>如何做呢?</p>
<p>​	代码中自定义熔断状态的监听器，监听熔断状态</p>
<p>第二步：熔断之后的降级：</p>
<p>正常情况走 DB，，异常了走 Redis</p>
<p><img src="C:\Users\Administrator\Nutstore\1\我的坚果云\笔记\面试准备\SpringCloud\image-20240618154329784.png" alt="image-20240618154329784"></p>
<h5 id="7：配置熔断数据的经验值"><a href="#7：配置熔断数据的经验值" class="headerlink" title="7：配置熔断数据的经验值"></a>7：配置熔断数据的经验值</h5><p>基本上做不到一步到位，渐进式的调整；</p>
<p>先设置一个基础值，再慢慢调整；</p>
<p>要根据业务量的考量，因为业务有高峰期和低谷期；</p>
<p>基础值：</p>
<p>​	熔断类型：设置为 QPS 或者线程数；一般设置为 QPS ，线程数不好把控。</p>
<p>​	熔断的最大 RT &#x3D; 根据压测 TP99  RT 基础上 * 120%</p>
<p>​        触发比例：一般设置为 3% - 5%</p>
<p>​	熔断时长：一般设置为 30 s</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/16/Springcloud/" data-id="clxs9nvts000tikuw084f7nua" data-title="服务治理" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringCloud/" rel="tag">SpringCloud</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-SpringBoot相关" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/16/SpringBoot%E7%9B%B8%E5%85%B3/" class="article-date">
  <time class="dt-published" datetime="2023-07-15T16:00:00.000Z" itemprop="datePublished">2023-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/16/SpringBoot%E7%9B%B8%E5%85%B3/">SpringBoot</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1：SpringBoot-自动装配原理"><a href="#1：SpringBoot-自动装配原理" class="headerlink" title="1：SpringBoot 自动装配原理"></a>1：SpringBoot 自动装配原理</h1><p>自动装配就是自动把第三方组件中的 bean 加载到 Spring 容器中，不需要开发人员再去写 bean 相关的配置。</p>
<p>在 springboot 中，只需要在启动类上加上 @SpringbootApplication 注解，就可以实现自动装配。</p>
<p>这个注解是一个复合注解，真正起作用的是 @EnableAutoConfiguration 注解；</p>
<p>这个注解的底层又是 @Import 注解，它最终通过 importSelect 来工作；</p>
<p>自动装配的实现主要涉及到 3 个核心的技术点：</p>
<ul>
<li><p>引入 starter</p>
<p>启动依赖组件的事件，必须要有 @configuration 配置类，配合 @Bean 注解。</p>
</li>
<li><p>编写配置</p>
<p>根据springboot 约定大于配置的原则</p>
<p>这些类会放在 classpath - matINF - spring.factories 文件中；</p>
</li>
<li><p>springFactoryLoader 去加载</p>
<p>spring 容器从这个文件中获取 key 为 enableAutoConfiguration 的类，然后根据 @ConditionXX 注解排除掉无效的类，</p>
<p>然后通过 spring 中的 springFactoryLoader 加载，最终通过 importSelect 接口，来动态加载它们，从而实现自动装配。</p>
</li>
</ul>
<h1 id="2：SpringBoot-启动流程"><a href="#2：SpringBoot-启动流程" class="headerlink" title="2：SpringBoot 启动流程"></a>2：SpringBoot 启动流程</h1><ul>
<li><p>初始化阶段</p>
<p>这一步确保，真正的启动前，各种设置都就绪。包括环境、初始化器、监听器、主启动类。</p>
<p>new SpringApplication 的过程是初始化 SpringApplication , 从 spring.factories 中读取：初始化器、监听器。</p>
<ul>
<li><p>添加源：通常是添加一些配置类</p>
</li>
<li><p>设置web环境</p>
</li>
<li><p>加载初始化器</p>
<p>从 spring.factories 文件中读取各种初始化器，加载到SpringApplication 中去；</p>
<p>这一步是 springboot 自动装配的核心；</p>
</li>
<li><p>设置监听器</p>
<p>为的是响应各种事件</p>
</li>
</ul>
</li>
<li><p>run方法</p>
<ul>
<li><p>记录开始启动时间</p>
</li>
<li><p>在启动前设置一个容器，用来缓存启动前的一些操作</p>
</li>
<li><p>触发监听器，发布开始启动事件，让监听者做一些额外的工作</p>
</li>
<li><p>将传入的参数封装起来</p>
</li>
<li><p>加载环境变量</p>
<p>JVM 环境变量、yml 中的环境变量；</p>
<p>触发监听器，发布加载环境变量完成的时间</p>
</li>
<li><p>打印 banner </p>
</li>
<li><p>创建 spring 容器</p>
</li>
<li><p>spring 容器启动之前的处理</p>
</li>
<li><p>启动 spring 容器</p>
<p>在这一步就是 IOC 的过程；</p>
<p>它会加载所有的自动配置类、创建bean、启动 tomcat</p>
</li>
<li><p>spring 容器启动后的处理</p>
</li>
<li><p>计算启动花费的时间</p>
</li>
<li><p>发布启动完成的事件。</p>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/16/SpringBoot%E7%9B%B8%E5%85%B3/" data-id="clxs9nvtp000nikuwe9shezpd" data-title="SpringBoot" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Spring IOC" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/06/16/Spring%20IOC/" class="article-date">
  <time class="dt-published" datetime="2023-06-15T16:00:00.000Z" itemprop="datePublished">2023-06-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/06/16/Spring%20IOC/">Spring IOC</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1：啥是-Spring-IOC"><a href="#1：啥是-Spring-IOC" class="headerlink" title="1：啥是 Spring IOC"></a>1：啥是 Spring IOC</h1><p>所谓的 IOC 意思是控制反转；</p>
<p>啥是控制反转呢？</p>
<p>相对于控制反转，传统的方式想使用一个对象，就是通过 new 的方式创建。</p>
<p>而 IOC，它是 spring 容器去创建对象并放在容器中，当需要的时候直接从容器中拿就行了。这个创建对象的控制权交给了spring。</p>
<p>IOC 是一种指导思想。它有许多实现方式.</p>
<h1 id="2-IOC-咋落地实现的呢"><a href="#2-IOC-咋落地实现的呢" class="headerlink" title="2: IOC 咋落地实现的呢"></a>2: IOC 咋落地实现的呢</h1><p>spring 从元数据拿到需要依赖注入的业务 POJO。</p>
<p>这个元数据可以是：xml、configuration 注解中的 bean 注解、各种bean注解。</p>
<p>拿到 POJO 之后，生成 BeanDefition，然后注入到spring 容器中。用的时候，要经过spring 上下文获取容器中的对象。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/06/16/Spring%20IOC/" data-id="clxs9nvtn000likuw11p2geu6" data-title="Spring IOC" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Spring Bean 的生命周期" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/16/Spring%20Bean%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" class="article-date">
  <time class="dt-published" datetime="2023-05-15T16:00:00.000Z" itemprop="datePublished">2023-05-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/16/Spring%20Bean%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">Spring bean 的生命周期</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>总的来说分为但三大步：创建、使用、销毁</p>
<p>细分：</p>
<h1 id="0-1：单例、多例检查"><a href="#0-1：单例、多例检查" class="headerlink" title="0.1：单例、多例检查"></a>0.1：单例、多例检查</h1><p>在实例化之前，会检查 bean 的作用域，如果是单例的，就在容器中找，有没有，有的化就被重用。</p>
<p>没有的话，才走实例化。</p>
<h1 id="1：实例化"><a href="#1：实例化" class="headerlink" title="1：实例化"></a>1：实例化</h1><p>​	spring 找到 bean 的元数据之后，首先会实例化 bean，如果有工厂方法，就用工厂方法创建，如果没有，就调用构造器创建。</p>
<p>​	这个过程就相当于新生儿出生，还未觉醒。</p>
<h1 id="1-1：实例化之后先使用三级缓存解决循环依赖"><a href="#1-1：实例化之后先使用三级缓存解决循环依赖" class="headerlink" title="1.1：实例化之后先使用三级缓存解决循环依赖"></a>1.1：实例化之后先使用三级缓存解决循环依赖</h1><h1 id="2：属性填充"><a href="#2：属性填充" class="headerlink" title="2：属性填充"></a>2：属性填充</h1><p>​	spring 根据元数据信息，为 bean 的属性赋值；相当于给新生儿穿衣打扮</p>
<h1 id="3：Aware-接口注入"><a href="#3：Aware-接口注入" class="headerlink" title="3：Aware 接口注入"></a>3：Aware 接口注入</h1><p>​	如何 bean 实现了 aware 接口，此时会执行那么方法。让 bean 知道自己的名字、所在的上下文；</p>
<p>​	相当于新生儿意识到自己是谁，在哪里</p>
<h1 id="4：初始化前置"><a href="#4：初始化前置" class="headerlink" title="4：初始化前置"></a>4：初始化前置</h1><p>​	BeanPostProcessor 的前置方法，可以改变当前状态的 bean ；</p>
<p>​	spring 遍历所有BeanPostProcessor 的实现类，执行前置方法；</p>
<p>​	相当于给孩子做一些额外工作；</p>
<p>​	</p>
<h1 id="4：初始化"><a href="#4：初始化" class="headerlink" title="4：初始化"></a>4：初始化</h1><p>​	真正的初始化。主要是 InitBean 接口。@PostConstruct 注解就是在这个阶段。</p>
<p>​	按顺序执行：@PostConstruct、afterPropertiesSet、 init-method、</p>
<p>​	相当于孩子开始上学，接受教育。</p>
<h1 id="5：初始化后置"><a href="#5：初始化后置" class="headerlink" title="5：初始化后置"></a>5：初始化后置</h1><p>​	BeanPostProcessor 的后置方法，对于初始化完成的bean 再次加工。</p>
<p>​	spring 遍历所有BeanPostProcessor 的实现类，执行后置方法；</p>
<p>​	相当于对孩子不断完善。</p>
<h1 id="5-1：aop-阶段"><a href="#5-1：aop-阶段" class="headerlink" title="5.1：aop 阶段"></a>5.1：aop 阶段</h1><p>BeanPostProcessor 的两个后置方法专门用来处理 aop：xxAspectJxx.</p>
<h1 id="6：销毁前置"><a href="#6：销毁前置" class="headerlink" title="6：销毁前置"></a>6：销毁前置</h1><p>​	DisPonseAble 接口指定的销毁方法</p>
<h1 id="7：销毁"><a href="#7：销毁" class="headerlink" title="7：销毁"></a>7：销毁</h1><p>​	Bean 被销毁，释放资源，生命周期结束。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/16/Spring%20Bean%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" data-id="clxs9nvtm000iikuwbdj9a6d6" data-title="Spring bean 的生命周期" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Spring AOP" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/16/Spring%20AOP/" class="article-date">
  <time class="dt-published" datetime="2023-04-15T16:00:00.000Z" itemprop="datePublished">2023-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/16/Spring%20AOP/">AOP</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1：AOP-是啥"><a href="#1：AOP-是啥" class="headerlink" title="1：AOP 是啥"></a>1：AOP 是啥</h1><h2 id="1：AOP-的概念"><a href="#1：AOP-的概念" class="headerlink" title="1：AOP 的概念"></a>1：AOP 的概念</h2><p>AOP 是面向切面编程；</p>
<p>就是把公共的逻辑抽出来，开发人员只用关注业务就行。</p>
<p>aop 是一种指导思想，它对接的是切面，具体实现有几种方式。</p>
<h2 id="2：AOP-中的几个点"><a href="#2：AOP-中的几个点" class="headerlink" title="2：AOP 中的几个点"></a>2：AOP 中的几个点</h2><ul>
<li><p>切面 &#x3D; 切入点 + 通知</p>
<p>就是定义了干什么和什么时候干的逻辑，使用 @PointCut 注解</p>
</li>
<li><p>切入点</p>
<p>表示应该拦截哪些方法，使用 execution 表达式</p>
</li>
<li><p>通知</p>
<p>表示拦截之后要做什么事情；</p>
<ul>
<li>前置通知</li>
<li>后置通知</li>
<li>前置后置通知</li>
<li>异常后的通知</li>
<li>finally 最终通知</li>
</ul>
</li>
<li><p>连接点</p>
</li>
<li><p>目标对象</p>
</li>
</ul>
<h2 id="3：实际工作中的作用场景"><a href="#3：实际工作中的作用场景" class="headerlink" title="3：实际工作中的作用场景"></a>3：实际工作中的作用场景</h2><ul>
<li><p>减少代码耦合、提高复用；</p>
</li>
<li><p>对方法增强；</p>
</li>
</ul>
<p>比如：想要监控一个方法的整体耗时；</p>
<p>于是定义一个切面，然后使用环绕通知，@around 注解；在方法执行前后加入监控的逻辑；</p>
<p>后期可以改进使用普罗米修斯 + granfna 来监控；</p>
<h1 id="2：AOP-咋思想落地的呢"><a href="#2：AOP-咋思想落地的呢" class="headerlink" title="2：AOP 咋思想落地的呢"></a>2：AOP 咋思想落地的呢</h1><p>AOP 要融入spring bean 生命周期的初始化过程，主要是 BeanPostProcessor 这个对象的两个方法起作用。</p>
<ul>
<li><p>初始化后置</p>
<p>spring 会判断是否需要为当前bean 创建代理，主要还是 beanpostprocessor 的两个方法起作用，它们会根据切面信息，判断是否需要创建代理对象。</p>
<ul>
<li><p>如果要创建代理对象</p>
<p>BeanPostProcessor 会用代理工厂或者 JDK 动态代理或者 CGLIB 代理创建代理对象，代理对象会在配置的通知点织入。</p>
</li>
<li><p>代理创建后</p>
<p>BeanPostProcessor 将原始对象替换为代理对象。从而保证后续调用这个bean 都是走的代理对象。</p>
</li>
</ul>
</li>
</ul>
<h1 id="3：AOP-的两种实现方式"><a href="#3：AOP-的两种实现方式" class="headerlink" title="3：AOP 的两种实现方式"></a>3：AOP 的两种实现方式</h1><p>基于动态代理模式实现；</p>
<ul>
<li><p>默认是 JDK 动态代理</p>
<p>使用反射，在运行期动态创建目标接口的实现类，在执行方法的时候走的是代理类 invoke 方法，然后它内部调用原始类的方法，在方法前后增强。</p>
<p>只能基于接口代理；</p>
</li>
<li><p>CGLIB 动态代理</p>
</li>
</ul>
<p>​	它是在运行时动态生成目标类的子类，不受接口的限制，它是基于字节码的操作，性能可能要好一点。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/16/Spring%20AOP/" data-id="clxs9nvtl000gikuwft9mg019" data-title="AOP" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-RPC" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/02/16/RPC/" class="article-date">
  <time class="dt-published" datetime="2023-02-15T16:00:00.000Z" itemprop="datePublished">2023-02-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/02/16/RPC/">RPC</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1：啥是-RPC"><a href="#1：啥是-RPC" class="headerlink" title="1：啥是 RPC"></a>1：啥是 RPC</h1><p>RPC 是远程过程调用，是一种进程间的通信方式。</p>
<p>它关注几个要素：</p>
<ul>
<li><p>传输协议、</p>
</li>
<li><p>通信框架</p>
</li>
<li><p>序列化协议、</p>
</li>
<li><p>集群、</p>
<p>负载均衡、集群容错</p>
</li>
<li><p>服务注册与发现就是服务寻址</p>
</li>
<li><p>动态代理方案实现像本地调用一样调远程服务</p>
</li>
<li><p>查询结果缓存起来</p>
</li>
</ul>
<p>HTTP 是超文本传输协议，它只是一个协议。</p>
<p>RPC 通常用于服务间的调用，HTTP 常用于 web、app、第三方的调用；</p>
<p>HTTP 的实现是基于 TCP ，RPC 也可以基于 TCP，或者 HTTP 实现。</p>
<h1 id="2：RPC-框架有哪些"><a href="#2：RPC-框架有哪些" class="headerlink" title="2：RPC 框架有哪些"></a>2：RPC 框架有哪些</h1><ul>
<li>Dubbo</li>
<li>阿里的 HSF</li>
<li>谷歌的 grpc</li>
</ul>
<h1 id="3：为啥-RPC-比-HTTP-更快一些"><a href="#3：为啥-RPC-比-HTTP-更快一些" class="headerlink" title="3：为啥 RPC 比 HTTP 更快一些"></a>3：为啥 RPC 比 HTTP 更快一些</h1><p>RPC 的设计目的就是为了快速传输，因此它的序列化比 HTTP 的更紧凑，没有像 HTTP 传输的还要带上 Header、body 那样，RPC 相对传输的数据量更少。</p>
<h1 id="3：RPC-原理，如何设计一个-RPC-框架"><a href="#3：RPC-原理，如何设计一个-RPC-框架" class="headerlink" title="3：RPC 原理，如何设计一个 RPC 框架"></a>3：RPC 原理，如何设计一个 RPC 框架</h1><p>首先一个 RPC 框架的几个要素是：</p>
<ul>
<li><p>配置层</p>
<p>可以 SPI 扩展</p>
</li>
<li><p>注册中心层</p>
</li>
<li><p>代理层</p>
</li>
<li><p>集群层</p>
</li>
<li><p>监控层</p>
</li>
<li><p>网络传输</p>
</li>
<li><p>序列化</p>
</li>
<li><p>通信协议</p>
</li>
</ul>
<p>通信框架可以使用高性能的 netty，不用自己造轮子；</p>
<p>要实现像本地方法一样调用远程方法，还得屏蔽上述细节，那就要使用代理来实现。要做到高可用，就得使用集群、还有服务注册中心、还得有一套完善的监控机制。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/02/16/RPC/" data-id="clxs9nvti000bikuwa8ba1bdj" data-title="RPC" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Dubbo/" rel="tag">Dubbo</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dubbo/" rel="tag">Dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-%E5%9F%BA%E7%A1%80/" rel="tag">Java 基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag">Java 并发编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-%E9%9B%86%E5%90%88/" rel="tag">Java 集合</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringCloud/" rel="tag">SpringCloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ZK/" rel="tag">ZK</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nacos/" rel="tag">nacos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag">微服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Dubbo/" style="font-size: 12px;">Dubbo</a> <a href="/tags/Java-%E5%9F%BA%E7%A1%80/" style="font-size: 20px;">Java 基础</a> <a href="/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 16px;">Java 并发编程</a> <a href="/tags/Java-%E9%9B%86%E5%90%88/" style="font-size: 18px;">Java 集合</a> <a href="/tags/Spring/" style="font-size: 14px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size: 10px;">SpringCloud</a> <a href="/tags/ZK/" style="font-size: 10px;">ZK</a> <a href="/tags/nacos/" style="font-size: 10px;">nacos</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 10px;">分布式</a> <a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 10px;">微服务</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 12px;">杂谈</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/12/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/">设计模式</a>
          </li>
        
          <li>
            <a href="/2023/11/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9B%B8%E5%85%B3/">微服务</a>
          </li>
        
          <li>
            <a href="/2023/10/16/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/">分布式</a>
          </li>
        
          <li>
            <a href="/2023/09/16/Nacos/">nacos</a>
          </li>
        
          <li>
            <a href="/2023/08/16/Springcloud/">服务治理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 张帅<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>